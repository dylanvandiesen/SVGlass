<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Metal Border Generator PRO</title>
  <style>
    :root {
      --border-size: 8;
      --radius: 28;

      --base-angle: 24;
      --scroll-progress: 0;
      --scroll-drive: 1;
      --light-elevation: 0.75;
      --light-intensity: 1.2;

      --conic-arms: 10;
      --arm-width: 0.38;
      --arm-contrast: 0.55;
      --arm-spin: 1.3;

      --bevel-outer: 0.85;
      --bevel-inner: 0.72;
      --bevel-softness: 0.5;

      --roughness: 0.22;
      --texture-scale: 1.1;
      --texture-strength: 0.28;

      --c1-r: 242; --c1-g: 247; --c1-b: 255; --c1-a: 0.98;
      --c2-r: 158; --c2-g: 171; --c2-b: 194; --c2-a: 0.85;
      --c3-r: 64;  --c3-g: 74;  --c3-b: 92;  --c3-a: 0.88;
      --c4-r: 255; --c4-g: 255; --c4-b: 255; --c4-a: 0.55;

      --center-alpha: 0;

      --outer-shadow-x: 0;
      --outer-shadow-y: 12;
      --outer-shadow-blur: 32;
      --outer-shadow-r: 0; --outer-shadow-g: 0; --outer-shadow-b: 0; --outer-shadow-a: 0.45;

      --inner-shadow-x: 0;
      --inner-shadow-y: 2;
      --inner-shadow-blur: 20;
      --inner-shadow-spread: 1;
      --inner-shadow-r: 8; --inner-shadow-g: 10; --inner-shadow-b: 16; --inner-shadow-a: 0.62;

      --mix-blend: normal;
      --f-brightness: 1;
      --f-contrast: 1.06;
      --f-saturate: 1.12;
      --f-hue: 0;
      --f-sepia: 0;
      --f-grayscale: 0;
      --f-invert: 0;
      --f-blur: 0;
    }

    @property --scroll-progress {
      syntax: "<number>";
      inherits: true;
      initial-value: 0;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 280vh;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #edf2ff;
      background: radial-gradient(circle at 15% 12%, #36405f 0%, #171a24 40%, #0b0d14 100%);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(300px, 420px) minmax(0, 1fr);
      gap: 1rem;
      padding: 1rem;
      align-items: start;
    }

    .controls {
      position: sticky;
      top: .5rem;
      max-height: calc(100vh - 1rem);
      overflow: auto;
      border-radius: 16px;
      padding: .9rem;
      background: rgba(15, 19, 30, .86);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.15);
    }

    h2 { margin: 0 0 .35rem; font-size: 1.1rem; }
    .controls p { margin: 0 0 .75rem; font-size: .84rem; opacity: .86; }
    .group { margin-top: .75rem; padding-top: .75rem; border-top: 1px solid rgba(255,255,255,.12); }
    .group h3 { margin: 0 0 .5rem; font-size: .88rem; }
    label { display:block; font-size:.79rem; margin-bottom:.42rem; }
    .cap { display:flex; justify-content:space-between; gap:.5rem; margin-bottom:.1rem; }
    input[type="range"], select, input[type="color"] { width:100%; }
    input[type="color"] { height: 38px; border: none; border-radius: 8px; background: transparent; }
    .row2 { display:grid; grid-template-columns: 1fr 1fr; gap:.5rem; }

    .stage {
      display:grid;
      place-items:center;
      min-height:95vh;
      padding:1rem;
    }

    .card {
      position: relative;
      width: min(92vw, 860px);
      min-height: min(62vh, 540px);
      border-radius: calc(var(--radius) * 1px);
      isolation: isolate;
      filter:
        brightness(var(--f-brightness))
        contrast(var(--f-contrast))
        saturate(var(--f-saturate))
        hue-rotate(calc(var(--f-hue) * 1deg))
        sepia(var(--f-sepia))
        grayscale(var(--f-grayscale))
        invert(var(--f-invert))
        blur(calc(var(--f-blur) * 1px));
    }

    /* Border is painted as a real ring directly by worklet (no CSS mask trick). */
    .border-layer {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: paint(metal-border);
      mix-blend-mode: var(--mix-blend);
      box-shadow:
        calc(var(--outer-shadow-x) * 1px)
        calc(var(--outer-shadow-y) * 1px)
        calc(var(--outer-shadow-blur) * 1px)
        rgba(var(--outer-shadow-r), var(--outer-shadow-g), var(--outer-shadow-b), var(--outer-shadow-a));
    }

    .inner-layer {
      position: absolute;
      inset: calc(var(--border-size) * 1px);
      border-radius: calc((var(--radius) - var(--border-size) * 0.5) * 1px);
      pointer-events: none;
      background: rgba(255,255,255,var(--center-alpha));
      box-shadow:
        inset calc(var(--inner-shadow-x) * 1px)
        calc(var(--inner-shadow-y) * 1px)
        calc(var(--inner-shadow-blur) * 1px)
        calc(var(--inner-shadow-spread) * 1px)
        rgba(var(--inner-shadow-r), var(--inner-shadow-g), var(--inner-shadow-b), var(--inner-shadow-a));
    }

    .content {
      position: absolute;
      inset: calc(var(--border-size) * 1px);
      border-radius: calc((var(--radius) - var(--border-size) * 0.5) * 1px);
      display:grid;
      place-items:center;
      text-align:center;
      padding:1.2rem;
      background: transparent;
    }

    .content h1 { margin:0; font-size:clamp(1.45rem,3vw,2.5rem); }
    .content p { max-width:44ch; opacity:.88; }

    @supports (animation-timeline: scroll()) {
      body {
        animation: prog linear both;
        animation-timeline: scroll(root);
        animation-range: 0% 100%;
      }
      @keyframes prog {
        from { --scroll-progress: 0; }
        to { --scroll-progress: 1; }
      }
    }

    @media (max-width: 920px) {
      .layout { grid-template-columns: 1fr; }
      .controls {
        position: fixed;
        left: .55rem;
        right: .55rem;
        bottom: .55rem;
        top: auto;
        max-height: 46vh;
        z-index: 20;
      }
      .stage { padding-bottom: 48vh; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="controls">
      <h2>Metal Border Generator PRO</h2>
      <p>Native CSS property animation for scroll (`--scroll-progress`) + fallback. Border conic is physically masked to ring only.</p>

      <div class="group">
        <h3>Geometry + Light</h3>
        <label><span class="cap">Border size <output data-out="--border-size"></output></span><input data-var="--border-size" type="range" min="0" max="96" step="0.1" value="8"></label>
        <label><span class="cap">Radius <output data-out="--radius"></output></span><input data-var="--radius" type="range" min="0" max="120" step="1" value="28"></label>
        <label><span class="cap">Base angle <output data-out="--base-angle"></output></span><input data-var="--base-angle" type="range" min="0" max="360" step="1" value="24"></label>
        <label><span class="cap">Scroll drive <output data-out="--scroll-drive"></output></span><input data-var="--scroll-drive" type="range" min="0" max="6" step="0.01" value="1"></label>
        <label><span class="cap">Light elevation <output data-out="--light-elevation"></output></span><input data-var="--light-elevation" type="range" min="0" max="1" step="0.01" value="0.75"></label>
        <label><span class="cap">Light intensity <output data-out="--light-intensity"></output></span><input data-var="--light-intensity" type="range" min="0" max="3" step="0.01" value="1.2"></label>
      </div>

      <div class="group">
        <h3>Conic Arms + Bevel + Texture</h3>
        <label><span class="cap">Arms <output data-out="--conic-arms"></output></span><input data-var="--conic-arms" type="range" min="1" max="36" step="1" value="10"></label>
        <label><span class="cap">Arm width <output data-out="--arm-width"></output></span><input data-var="--arm-width" type="range" min="0.01" max="0.99" step="0.01" value="0.38"></label>
        <label><span class="cap">Arm contrast <output data-out="--arm-contrast"></output></span><input data-var="--arm-contrast" type="range" min="0" max="1" step="0.01" value="0.55"></label>
        <label><span class="cap">Arm spin <output data-out="--arm-spin"></output></span><input data-var="--arm-spin" type="range" min="0" max="5" step="0.01" value="1.3"></label>
        <label><span class="cap">Bevel outer <output data-out="--bevel-outer"></output></span><input data-var="--bevel-outer" type="range" min="0" max="2" step="0.01" value="0.85"></label>
        <label><span class="cap">Bevel inner <output data-out="--bevel-inner"></output></span><input data-var="--bevel-inner" type="range" min="0" max="2" step="0.01" value="0.72"></label>
        <label><span class="cap">Bevel softness <output data-out="--bevel-softness"></output></span><input data-var="--bevel-softness" type="range" min="0.05" max="2" step="0.01" value="0.5"></label>
        <label><span class="cap">Roughness <output data-out="--roughness"></output></span><input data-var="--roughness" type="range" min="0" max="1" step="0.01" value="0.22"></label>
        <label><span class="cap">Texture scale <output data-out="--texture-scale"></output></span><input data-var="--texture-scale" type="range" min="0.1" max="10" step="0.01" value="1.1"></label>
        <label><span class="cap">Texture strength <output data-out="--texture-strength"></output></span><input data-var="--texture-strength" type="range" min="0" max="1" step="0.01" value="0.28"></label>
      </div>

      <div class="group"><h3>Metal Colors + Alpha</h3><div id="colors"></div></div>

      <div class="group">
        <h3>Center + Shadows + Blend + Filters</h3>
        <label><span class="cap">Center alpha (0=true transparent) <output data-out="--center-alpha"></output></span><input data-var="--center-alpha" type="range" min="0" max="1" step="0.01" value="0"></label>

        <div class="row2">
          <label><span class="cap">Outer shadow color</span><input id="outer-color" type="color" value="#000000"></label>
          <label><span class="cap">Inner shadow color</span><input id="inner-color" type="color" value="#080a10"></label>
        </div>

        <label><span class="cap">Outer X <output data-out="--outer-shadow-x"></output></span><input data-var="--outer-shadow-x" type="range" min="-80" max="80" step="1" value="0"></label>
        <label><span class="cap">Outer Y <output data-out="--outer-shadow-y"></output></span><input data-var="--outer-shadow-y" type="range" min="-80" max="80" step="1" value="12"></label>
        <label><span class="cap">Outer blur <output data-out="--outer-shadow-blur"></output></span><input data-var="--outer-shadow-blur" type="range" min="0" max="160" step="1" value="32"></label>
        <label><span class="cap">Outer alpha <output data-out="--outer-shadow-a"></output></span><input data-var="--outer-shadow-a" type="range" min="0" max="1" step="0.01" value="0.45"></label>

        <label><span class="cap">Inner X <output data-out="--inner-shadow-x"></output></span><input data-var="--inner-shadow-x" type="range" min="-80" max="80" step="1" value="0"></label>
        <label><span class="cap">Inner Y <output data-out="--inner-shadow-y"></output></span><input data-var="--inner-shadow-y" type="range" min="-80" max="80" step="1" value="2"></label>
        <label><span class="cap">Inner blur <output data-out="--inner-shadow-blur"></output></span><input data-var="--inner-shadow-blur" type="range" min="0" max="160" step="1" value="20"></label>
        <label><span class="cap">Inner spread <output data-out="--inner-shadow-spread"></output></span><input data-var="--inner-shadow-spread" type="range" min="-80" max="80" step="1" value="1"></label>
        <label><span class="cap">Inner alpha <output data-out="--inner-shadow-a"></output></span><input data-var="--inner-shadow-a" type="range" min="0" max="1" step="0.01" value="0.62"></label>

        <label><span class="cap">Blend mode</span>
          <select data-var="--mix-blend">
            <option>normal</option><option>overlay</option><option>screen</option><option>multiply</option>
            <option>soft-light</option><option>hard-light</option><option>color-dodge</option><option>color-burn</option>
            <option>difference</option><option>luminosity</option>
          </select>
        </label>

        <label><span class="cap">Brightness <output data-out="--f-brightness"></output></span><input data-var="--f-brightness" type="range" min="0.3" max="3" step="0.01" value="1"></label>
        <label><span class="cap">Contrast <output data-out="--f-contrast"></output></span><input data-var="--f-contrast" type="range" min="0.2" max="4" step="0.01" value="1.06"></label>
        <label><span class="cap">Saturate <output data-out="--f-saturate"></output></span><input data-var="--f-saturate" type="range" min="0" max="4" step="0.01" value="1.12"></label>
        <label><span class="cap">Hue <output data-out="--f-hue"></output></span><input data-var="--f-hue" type="range" min="0" max="360" step="1" value="0"></label>
        <label><span class="cap">Sepia <output data-out="--f-sepia"></output></span><input data-var="--f-sepia" type="range" min="0" max="1" step="0.01" value="0"></label>
        <label><span class="cap">Grayscale <output data-out="--f-grayscale"></output></span><input data-var="--f-grayscale" type="range" min="0" max="1" step="0.01" value="0"></label>
        <label><span class="cap">Invert <output data-out="--f-invert"></output></span><input data-var="--f-invert" type="range" min="0" max="1" step="0.01" value="0"></label>
        <label><span class="cap">Blur <output data-out="--f-blur"></output></span><input data-var="--f-blur" type="range" min="0" max="12" step="0.1" value="0"></label>
      </div>
    </aside>

    <main class="stage">
      <div class="card">
        <div class="border-layer"></div>
        <div class="inner-layer"></div>
        <div class="content">
          <div>
            <h1>Metal Border Worklet PRO</h1>
            <p>Conic light is forced to border ring only. Native CSS scroll-driven property animation when supported, JS fallback when not.</p>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script>
    const WORKLET = `
class MetalBorderPainter {
  static get inputProperties() {
    return [
      '--border-size','--radius',
      '--base-angle','--scroll-progress','--scroll-drive','--light-elevation','--light-intensity',
      '--conic-arms','--arm-width','--arm-contrast','--arm-spin',
      '--bevel-outer','--bevel-inner','--bevel-softness',
      '--roughness','--texture-scale','--texture-strength',
      '--c1-r','--c1-g','--c1-b','--c1-a',
      '--c2-r','--c2-g','--c2-b','--c2-a',
      '--c3-r','--c3-g','--c3-b','--c3-a',
      '--c4-r','--c4-g','--c4-b','--c4-a'
    ];
  }
  p(props, n, d=0){ const v = parseFloat((props.get(n) || '').toString()); return Number.isFinite(v) ? v : d; }
  c(props, i){ return [this.p(props,'--c'+i+'-r',255),this.p(props,'--c'+i+'-g',255),this.p(props,'--c'+i+'-b',255),this.p(props,'--c'+i+'-a',1)]; }
  hash(x,y){ return (Math.sin(x*12.9898+y*78.233)*43758.5453)%1; }

  paint(ctx, size, props) {
    const w=size.width, h=size.height;
    const border=Math.max(0, this.p(props,'--border-size',8));
    if (border <= 0.01) return;

    const radius=Math.max(0, this.p(props,'--radius',24));
    const base=this.p(props,'--base-angle',0);
    const prog=this.p(props,'--scroll-progress',0);
    const drive=this.p(props,'--scroll-drive',1);
    const angle=((base + prog*360*drive)%360)*(Math.PI/180);

    const elev=this.p(props,'--light-elevation',0.75);
    const inten=this.p(props,'--light-intensity',1.2);

    const arms=Math.max(1, Math.floor(this.p(props,'--conic-arms',10)));
    const armW=Math.max(0.01, Math.min(0.99, this.p(props,'--arm-width',0.38)));
    const armC=this.p(props,'--arm-contrast',0.55);
    const armSpin=this.p(props,'--arm-spin',1.3);

    const bOuter=this.p(props,'--bevel-outer',0.85);
    const bInner=this.p(props,'--bevel-inner',0.72);
    const bSoft=Math.max(0.03, this.p(props,'--bevel-softness',0.5));

    const rough=this.p(props,'--roughness',0.22);
    const texS=Math.max(0.1, this.p(props,'--texture-scale',1.1));
    const texA=this.p(props,'--texture-strength',0.28);

    const c1=this.c(props,1), c2=this.c(props,2), c3=this.c(props,3), c4=this.c(props,4);

    const cx=w*0.5, cy=h*0.5;
    const midInset = border * 0.5;
    const rw = Math.max(0, w - midInset*2);
    const rh = Math.max(0, h - midInset*2);
    const rr = Math.max(0, radius - midInset);

    ctx.save();

    // Base conic on border stroke only (never center fill)
    const baseGrad = ctx.createConicGradient(angle, cx, cy);
    baseGrad.addColorStop(0.00, 'rgba('+c1[0]+','+c1[1]+','+c1[2]+','+c1[3]+')');
    baseGrad.addColorStop(0.25, 'rgba('+c2[0]+','+c2[1]+','+c2[2]+','+c2[3]+')');
    baseGrad.addColorStop(0.62, 'rgba('+c3[0]+','+c3[1]+','+c3[2]+','+c3[3]+')');
    baseGrad.addColorStop(1.00, 'rgba('+c4[0]+','+c4[1]+','+c4[2]+','+c4[3]+')');

    ctx.strokeStyle = baseGrad;
    ctx.lineWidth = border;
    ctx.beginPath();
    ctx.roundRect(midInset, midInset, rw, rh, rr);
    ctx.stroke();

    // Multi-arm conic overlay on border stroke only
    const armGrad = ctx.createConicGradient(angle*armSpin, cx, cy);
    for (let i=0;i<arms;i++) {
      const s=i/arms;
      const m=(i+armW*0.5)/arms;
      const e=(i+armW)/arms;
      armGrad.addColorStop(s%1, 'rgba(255,255,255,0)');
      armGrad.addColorStop(m%1, 'rgba(255,255,255,'+(0.3*armC)+')');
      armGrad.addColorStop(e%1, 'rgba(0,0,0,'+(0.16*armC)+')');
    }
    ctx.globalCompositeOperation='overlay';
    ctx.strokeStyle=armGrad;
    ctx.lineWidth=border;
    ctx.beginPath();
    ctx.roundRect(midInset, midInset, rw, rh, rr);
    ctx.stroke();
    ctx.globalCompositeOperation='source-over';

    // Bevel: explicit outer and inner border-edge strokes
    const lx=Math.cos(angle), ly=Math.sin(angle);
    const g0x=cx-lx*cx, g0y=cy-ly*cy;
    const g1x=cx+lx*cx, g1y=cy+ly*cy;

    const outerHi = ctx.createLinearGradient(g0x,g0y,g1x,g1y);
    outerHi.addColorStop(0, 'rgba(255,255,255,0)');
    outerHi.addColorStop(1, 'rgba(255,255,255,'+(0.56*bOuter*inten*(0.65+elev*0.5))+')');

    const innerLo = ctx.createLinearGradient(g0x,g0y,g1x,g1y);
    innerLo.addColorStop(0, 'rgba(0,0,0,'+(0.52*bInner)+')');
    innerLo.addColorStop(1, 'rgba(0,0,0,0)');

    const passes=Math.max(1, Math.floor(border));
    for (let i=0;i<passes;i++) {
      const t=i/Math.max(1,passes-1);
      const a=Math.pow(1-t, 1.2/bSoft);

      const outerInset=0.5+i;
      const ow=Math.max(0,w-outerInset*2), oh=Math.max(0,h-outerInset*2);
      ctx.strokeStyle=outerHi;
      ctx.globalAlpha=a*0.5;
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.roundRect(outerInset,outerInset,ow,oh,Math.max(0,radius-outerInset));
      ctx.stroke();

      const innerInset=Math.max(0,border-0.5-i);
      const ix=innerInset+border, iy=innerInset+border;
      const iw=Math.max(0,w-ix*2), ih=Math.max(0,h-iy*2);
      ctx.strokeStyle=innerLo;
      ctx.globalAlpha=a*0.46;
      ctx.beginPath();
      ctx.roundRect(ix,iy,iw,ih,Math.max(0,radius-border-innerInset));
      ctx.stroke();
    }
    ctx.globalAlpha=1;

    // Light-weight texture: sparse border-following speckles (not full-surface loops)
    const perim = Math.max(1, 2*(rw+rh));
    const dots = Math.min(900, Math.floor((perim / 4) * (0.35 + texS*0.25)));
    const dotA = texA * (0.04 + rough * 0.16);
    ctx.fillStyle='rgba(255,255,255,'+dotA+')';
    for (let i=0;i<dots;i++) {
      const u = i / dots;
      const side = Math.floor(u * 4);
      const t = (u * 4) - side;
      let x = 0, y = 0;
      if (side === 0) { x = midInset + rw * t; y = midInset; }
      else if (side === 1) { x = midInset + rw; y = midInset + rh * t; }
      else if (side === 2) { x = midInset + rw * (1-t); y = midInset + rh; }
      else { x = midInset; y = midInset + rh * (1-t); }
      const jx = (this.hash(i, 11.3)-0.5) * border * 0.55;
      const jy = (this.hash(i, 29.7)-0.5) * border * 0.55;
      const r = Math.max(0.4, this.hash(i, 47.1) * 1.2);
      ctx.beginPath();
      ctx.arc(x+jx, y+jy, r, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }
}
registerPaint('metal-border', MetalBorderPainter);
`;

(async () => {
  if (!('paintWorklet' in CSS)) {
    alert('CSS Paint API not supported in this browser.');
    return;
  }
  const blob = new Blob([WORKLET], { type: 'text/javascript' });
  await CSS.paintWorklet.addModule(URL.createObjectURL(blob));
})();

const root = document.documentElement;
const inputs = document.querySelectorAll('[data-var]');
const outputs = document.querySelectorAll('[data-out]');

function setVar(name, value){ root.style.setProperty(name, String(value)); }
function setOut(name, value){ const el=document.querySelector('[data-out="'+name+'"]'); if (el) el.textContent=String(value); }

inputs.forEach((el) => {
  const key = el.dataset.var;
  const apply = () => { setVar(key, el.value); setOut(key, el.value); };
  el.addEventListener('input', apply, { passive: true });
  apply();
});
outputs.forEach((el) => {
  if (!el.textContent) {
    const k=el.dataset.out;
    el.textContent=getComputedStyle(root).getPropertyValue(k).trim();
  }
});

// Fallback for browsers without scroll-timeline support
const hasScrollTimeline = CSS.supports('animation-timeline: scroll()');
if (!hasScrollTimeline) {
  let rafId = 0;
  const updateScrollProgress = () => {
    rafId = 0;
    const max = Math.max(1, document.documentElement.scrollHeight - innerHeight);
    const p = Math.max(0, Math.min(1, scrollY / max));
    setVar('--scroll-progress', p.toFixed(6));
  };
  const onScroll = () => {
    if (rafId) return;
    rafId = requestAnimationFrame(updateScrollProgress);
  };
  addEventListener('scroll', onScroll, { passive: true });
  updateScrollProgress();
}

function hexToRgb(hex){ const v=parseInt(hex.replace('#',''),16); return {r:(v>>16)&255,g:(v>>8)&255,b:v&255}; }
function bindShadowPicker(id, prefix){
  const el=document.getElementById(id);
  const apply=()=>{ const c=hexToRgb(el.value); setVar('--'+prefix+'-r', c.r); setVar('--'+prefix+'-g', c.g); setVar('--'+prefix+'-b', c.b); };
  el.addEventListener('input', apply, { passive: true });
  apply();
}
bindShadowPicker('outer-color','outer-shadow');
bindShadowPicker('inner-color','inner-shadow');

const colorHost = document.getElementById('colors');
const defaults = [
  {hex:'f2f7ff', a:0.98},
  {hex:'9eabc2', a:0.85},
  {hex:'404a5c', a:0.88},
  {hex:'ffffff', a:0.55},
];
for (let i=1;i<=4;i++) {
  const row=document.createElement('div');
  row.className='row2';
  row.innerHTML=
    '<label><span class="cap">Color '+i+'</span><input type="color" data-color="'+i+'" value="#'+defaults[i-1].hex+'"></label>'+
    '<label><span class="cap">Alpha '+i+'</span><input type="range" data-alpha="'+i+'" min="0" max="1" step="0.01" value="'+defaults[i-1].a+'"></label>';
  colorHost.appendChild(row);
}
colorHost.addEventListener('input', (e) => {
  const t=e.target;
  if (t.matches('[data-color]')) {
    const i=t.dataset.color;
    const c=hexToRgb(t.value);
    setVar('--c'+i+'-r', c.r); setVar('--c'+i+'-g', c.g); setVar('--c'+i+'-b', c.b);
  }
  if (t.matches('[data-alpha]')) {
    setVar('--c'+t.dataset.alpha+'-a', t.value);
  }
});
for (const el of colorHost.querySelectorAll('[data-color],[data-alpha]')) el.dispatchEvent(new Event('input'));
  </script>
</body>
</html>
